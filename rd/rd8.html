<!DOCTYPE html>
<html>
<style>
    body {
        margin: 0;
        padding: 0;
        background-color: hsl(0, 0%, 8%);
        /* background-color: #a4a4a4;     */
        width: 100vw;
        height: 100vh;
    }

    canvas {
        box-shadow: 0 0 10px 0px #5f5f5f;
    }

    .lil-gui {
        --width: 50%
    }
</style>

<body>
    <div id="container" style="
            height: 100%;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: center;">
    </div>
    <script src="js/three.min.js"></script>
    <script src="js/lil-gui.js"></script>
    <script id="vertexShader" type="x-shader/x-vertex">
        void main() {
            gl_Position = vec4( position, 1.0 );
        }
    </script>
    <script id="fragmentShaderOutput" type="x-shader/x-fragment">
        uniform vec2 u_resolution;
        uniform sampler2D u_tex;
        uniform sampler2D u_colour_map;

        void main() {
            vec2 uv = gl_FragCoord.xy/u_resolution.xy; 
            /*uv *= 2.; // tiling
            uv.x%=1.;
            uv.y%=1.;*/
            vec3 col = vec3(1.0-smoothstep(0.37, 0.5, texture2D(u_tex, uv).r));
            //vec3 col = texture2D(u_colour_map, vec2(texture2D(u_tex, uv).r, 0.5)).rgb;
            
            gl_FragColor=vec4(col, 1.0);
            
        }
    </script>
    <script id="fragmentShaderReaction" type="x-shader/x-fragment">
        uniform vec2 u_resolution;
        uniform float u_time;
        uniform vec2 u_mouse;
        uniform bool u_drawing;
        uniform bool u_mouse_controls_params;
        uniform bool u_wrap;
        uniform sampler2D u_tex;

        uniform float f;
        uniform float k;
        uniform float Da;
        uniform float Db;
        uniform float dt;



        vec2 wrap(vec2 coord) {
            if (u_wrap) {
                coord.x = mod(1.0 + coord.x, 1.0);
                coord.y = mod(1.0 + coord.y, 1.0);
            } else {
                coord.x = clamp(coord.x, 0.0, 1.0);
                coord.y = clamp(coord.y, 0.0, 1.0);
            }

            return coord;
        
        }
        float ease(float p, float g) {
            if (p < 0.5)
              return 0.5 * pow(2.*p, g);
            else
              return 1. - 0.5 * pow(2.*(1. - p), g);
          }

        void main() {
            
            vec2 pos = gl_FragCoord.xy;
            vec2 r = u_resolution.xy;
            vec2 m = u_mouse/u_resolution;

            vec2 uv = pos/r;
            //vec2 uv = (pos / r / scale) + ((1.0/scale*0.5 + (0.5 - 1.0/scale))); 


            float scale = 1.;// pow(30.,length(uv-vec2(0.5)));
            
            
            vec2 col = vec2(0.0,0.0);
            if (u_time <.02) {
                if (abs(mod(uv.x+u_time*0.0, 1.0)-0.5) < 0.25 && abs(mod(uv.y+u_time*0.0, 1.0)-0.5) < 0.25 ) {
                    col = vec2(0.0, 1.0);
                } else {
                    col = vec2(1.0, 0.0);
                }             
            } else {
                float kill = k;
                float feed = f;
                


                col = texture2D(u_tex, uv).rg;

                float A = col.r;
                float B = col.g;


                float v = m.x*.2;

                vec2 laplacian = vec2(-A, -B);

                float v1 = 0.05;
                float v2 = 0.20;

                laplacian += v1 * texture2D(u_tex, wrap((pos + vec2(-1,-1))/r)).rg;
                laplacian += v2 * texture2D(u_tex, wrap((pos + vec2(0,-1))/r)).rg;
                laplacian += v1 * texture2D(u_tex, wrap((pos + vec2(1,-1))/r)).rg;
                laplacian += v2 * texture2D(u_tex, wrap((pos + vec2(1,0))/r)).rg;
                laplacian += v1 * texture2D(u_tex, wrap((pos + vec2(1,1))/r)).rg;
                laplacian += v2 * texture2D(u_tex, wrap((pos + vec2(0,1))/r)).rg;
                laplacian += v1 * texture2D(u_tex, wrap((pos + vec2(-1,1))/r)).rg;
                laplacian += v2 * texture2D(u_tex, wrap((pos + vec2(-1,0))/r)).rg;

                float reaction = A*B*B;
                float delta_A = (Da*laplacian.r*(scale) - reaction + feed*(1.0-A))/scale;
                float delta_B = (Db*laplacian.g*(scale) + reaction - (feed+kill)*B)/scale;
                A += delta_A;
                B += delta_B;
                
                A = clamp(A, 0.0, 1.0);
                B = clamp(B, 0.0, 1.0);


                float brush_size = 5.0;
                float mouse_src = step(length(pos - vec2(u_mouse.x, u_resolution.y-u_mouse.y)), brush_size) * float(u_drawing);



                col = vec2(A, mix(B, 0.5, mouse_src));
                
            }
            
            
            gl_FragColor = vec4(col, 0.0, 1.0);
            
            
        }
    </script>
    <script>
        var container;
        var camera, scene, renderer, clock;
        var uniforms, uniforms_output;

        var reactions_per_frame = 12;
        let my_texture0;
        let my_texture1;


        var feed = 0.055;
        var kill = 0.062;
        var Da = 1.0;
        var Db = 0.5;
        var dt = 1.0;

        // perpetual mess
        // feed = 0.0353737373
        // kill = 0.0564680091
        




        const init_data = new THREE.DataTexture(
            new Float32Array([1.0, 1.0, 0.0, 1.0]), 1, 1); // data array has structure [r1,g1,b1,a1,r2,g2,...]
        init_data.format = THREE.RGBAFormat;
        init_data.type = THREE.FloatType;
        init_data.needsUpdate = true;


        function map_(value, start1, stop1, start2, stop2) {
            return (value - start1) / (stop1 - start1) * (stop2 - start2) + start2;
        }
        function lerp(start, stop, value) {
            return map_(value, 0, 1, start, stop);
        }

        var image = document.createElement('img');
        const colour_map = new THREE.Texture(image);
        image.src = 'data/col_map1.png';

        colour_map.format = THREE.RGBAFormat;
        init_data.type = THREE.FloatType;
        colour_map.needsUpdate = true;
        colour_map.magFilter = THREE.LinearFilter;



        const gui = new lil.GUI;
        // var mouse_controls_parms = false;

        var get_im_data = false;
        var play_pause = true;


        init();
        animate();
        

        function saveImage() {
            get_im_data = true;
        }
        function playPause() {
            play_pause = !play_pause;
        }



        function init() {
            container = document.getElementById('container');

            camera = new THREE.Camera();
            camera.position.z = 1;

            scene = new THREE.Scene();
            clock = new THREE.Clock();

            renderer = new THREE.WebGLRenderer();

            my_texture0 = new THREE.WebGLRenderTarget(0, 0, {
                minFilter: THREE.NearestFilter,
                magFilter: THREE.NearestFilter,
                format: THREE.RGBAFormat,
                type: THREE.FloatType
            });

            my_texture1 = my_texture0.clone();

            var geometry = new THREE.PlaneGeometry(2, 2);

            uniforms = {
                u_time: { type: "f", value: 0.0 },
                u_resolution: { type: "v2", value: new THREE.Vector2() },
                u_mouse: { type: "v2", value: new THREE.Vector3() },
                u_drawing: { type: "b", value: false },
                u_mouse_controls_params: { type: "b", value: false },
                u_tex: { type: "t", value: init_data },
                u_wrap: {type: "b", value: true},
                f: { type: "f", value: feed },
                k: { type: "f", value: kill },
                Da: { type: "f", value: Da },
                Db: { type: "f", value: Db },
                dt: { type: "f", value: dt },

            };

            uniforms_output = {
                u_resolution: { type: "v2", value: new THREE.Vector2() },
                u_tex: { type: "t", value: my_texture0.texture },
                u_colour_map: { type: "t", value: colour_map }
            };


            obj = {
                gui_mouse_control: false,
                gui_feed: feed,
                gui_kill: kill,
                gui_iterations: reactions_per_frame,
                gui_wrap: true,
                gui_play_pause: playPause,
                gui_save_im: saveImage
            };


            function set_mouse_controls(value) {
                uniforms.u_mouse_controls_params.value = value;
                if (value) {
                    controller_feed.disable();
                    controller_kill.disable();
                } else {
                    controller_feed.enable();
                    controller_kill.enable();
                }
            }
            function set_feed(value) {
                uniforms.f.value = value;
            }
            function set_kill(value) {
                uniforms.k.value = value;
            }
            function set_wrap(value) {
                uniforms.u_wrap.value = value;
            }

            const controller_mouse = gui.add(obj, 'gui_mouse_control')
                .name('Control parameters with mouse (m)')
                .listen()
                .onChange(value => set_mouse_controls(value));
            const controller_feed = gui.add(obj, 'gui_feed', 0.002, 0.12)
                .name('Feed')
                .listen()
                .onChange(value => set_feed(value));
            const controller_kill = gui.add(obj, 'gui_kill', 0.0141, 0.066)
                .name('Kill')
                .listen()
                .onChange(value => set_kill(value));
            const controller_it = gui.add(obj, 'gui_iterations', 1, 50, 1)
                .name('Reactions per frame')
                .onChange(
                    value => {
                        reactions_per_frame = value;
                    }
                );
            const controller_wrap = gui.add(obj, 'gui_wrap')
                .name('Wrap borders (w)')
                .listen()
                .onChange(value => set_wrap(value));
            const controller_play = gui.add(obj, 'gui_play_pause')
                .name('Play / Pause (spacebar)');
            const controller_save = gui.add(obj, 'gui_save_im')
                .name('Save image (s)');

            console.log("hi");
            material_reaction = new THREE.ShaderMaterial({
                uniforms: uniforms,
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShaderReaction').textContent
            });


            material_output = new THREE.ShaderMaterial({
                uniforms: uniforms_output,
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShaderOutput').textContent
            });


            mesh = new THREE.Mesh(geometry, material_output);
            scene.add(mesh);


            container.appendChild(renderer.domElement);

            onWindowResize();
            // window.addEventListener('resize', onWindowResize, false);

            document.onmousemove = function (e) {
                uniforms.u_mouse.value.x = e.clientX - renderer.domElement.offsetLeft;
                uniforms.u_mouse.value.y = e.clientY - renderer.domElement.offsetTop;

                let mx = uniforms.u_mouse.value.x / renderer.domElement.width;
                let my = uniforms.u_mouse.value.y / renderer.domElement.height;

                if (uniforms.u_mouse_controls_params.value) {
                    obj.gui_feed = lerp(0.002, 0.12, Math.min(Math.max(1 - my, 0), 1));
                    let kill_min = -7.919 * Math.pow(obj.gui_feed - 0.0686, 2.0) + 0.0599;
                    let kill_max = -3.418 * Math.pow(obj.gui_feed - 0.0536, 2.0) + 0.066;
                    obj.gui_kill = lerp(kill_min, kill_max, mx);

                    set_feed(obj.gui_feed);
                    set_kill(obj.gui_kill);
                }
            }
            document.onmousedown = function () {
                uniforms.u_drawing.value = true;
            }
            document.onmouseup = function () {
                uniforms.u_drawing.value = false;
            }
            document.onkeydown = function (e) {
                if (e.keyCode === 77) {// && e.ctrlKey) {
                    obj.gui_mouse_control = !obj.gui_mouse_control;
                    set_mouse_controls(obj.gui_mouse_control);
                }
                if (e.keyCode === 83) {
                    saveImage();
                }
                if (e.keyCode === 32) {
                    playPause();
                }
                if (e.keyCode === 87) {
                    obj.gui_wrap = !obj.gui_wrap;
                    set_wrap(obj.gui_wrap);
                }
            }
        }

        function onWindowResize(event) {
            var margin = 0.3;
            let width = window.innerWidth - window.innerHeight * margin;
            let height = window.innerHeight * (1 - margin);

            renderer.setSize(width, height);
            uniforms.u_resolution.value.x = renderer.domElement.width;
            uniforms.u_resolution.value.y = renderer.domElement.height;
            uniforms_output.u_resolution.value.x = renderer.domElement.width;
            uniforms_output.u_resolution.value.y = renderer.domElement.height;

            my_texture0.setSize(width, height);
            my_texture1.setSize(width, height);
        }

        function animate() {
            requestAnimationFrame(animate);
            render();
        }

        function render() {
            // console.log(obj['Control parameters with mouse']);


            uniforms.u_time.value += clock.getDelta();

            // uniforms_output.u_init.value = init_data;
            // uniforms_output.u_time.value = uniforms.u_time.value;

            mesh.material = material_reaction;

            if (play_pause)
                for (var i = 0; i < reactions_per_frame; i++) {
                    // mesh.material.uniforms.u_iteration.value = i;
                    renderer.setRenderTarget(my_texture0);
                    renderer.render(scene, camera);
                    renderer.setRenderTarget(null);


                    let tmp = my_texture0;
                    my_texture0 = my_texture1;
                    my_texture1 = tmp;

                    mesh.material.uniforms.u_tex.value = my_texture1.texture;
                }

            mesh.material = material_output;

            // mesh.material.uniforms.u_init.value = init_data;

            renderer.render(scene, camera);

            if (get_im_data) {

                img_data = renderer.domElement.toDataURL('image/jpeg', 1.0);

                var link = document.createElement('a');

                link.setAttribute('href', img_data);
                link.setAttribute('target', '_blank');
                link.setAttribute('download', "reactiondiffusion_image");

                link.click();
                get_im_data = false;
            }

        }
    </script>
</body>

</html>